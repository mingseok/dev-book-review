# 2장 이상한 나라의 객체

> 객체지향 패러다임은 지식을 추상화하고 추상화한 지식을 객체 안에 캡슐화함으로써 실세계 문제에 내재된 복잡성을 관리하려고 한다. 객체를 발견하고 창조하는 것은 지식과 행동을 구조화하는 문제다.

## 객체지향과 인지 능력

---

### 객체

> 객체지향 패러다임은 인간이 인지할 수 잇는 다양한 객체들이 모여 현실세계를 이루는 것처럼, 소프트웨어의 세계 역시 다양한 소프트웨어 객체들이 모여 이뤄져 있다는 믿음에서 출발한다
-> 현실세계의 전등은 사람의 손길 없이는 불이 켜지지 않지만, 소프트웨어 세계의 전등은 외부의 도움 없이도 스스로 전원을 켜거나 끌 수 있다.
자동차가 스스로 시동을 걸고, 통장이 스스로 금액을 인출하는 세상


## 객체, 그리고 이상한 나라
---

앨리스

- 앨리스의 행동에 따라 앨리스의 상태가 변한다.
- 앨리스가 한 행동의 결과는 앨리스의 **상태**에 의존적이다.
    - 케잌, 부채등에 의해 앨리스의 **현재 키**가 변한다.
    - **현재 키**에 의해 문을 통과할 수 있는 지에 대한 여부가 변한다.
    - 문을 통과하는 과정을 통해 **앨리스의 위치**가 변하는 것을 확인할 수 있다.
- 어떤 행동의 성공 여부는 이전에 어떤 행동들이 발생했는지에 영향을 받는다.
    - 행동간의 **순서**가 중요
- 행동에 의해 앨리스의 상태가 변경되더라도 앨리스가 앨리스라는 사실은 변하지 않는다.
    - 앨리스는 상태 변경과 무관하게 유일한 존재로 **식별 가능**하다.



## 객체, 그리고 소프트웨어 나라

---

객체: **상태(state), 행동(behavior), 식별자(identity)**를 지닌 실체

> 객체란 식별 가능한 개체 또는 사물이다. 객체는 자동차처럼 만질 수 있는 구체적인 사물일 수도 있고, 시간처럼 추상적인 개념일 수도 있다. 객체는 **구별 가능한 식별자, 특징적인 행동, 변경 가능한 상태**를 가진다. 소프트웨어 안에서 객체는 **저장된 상태**와 **실행 가능한 코드**를 통해 구현된다.
> 

### 상태

객체가 주변 환경과의 상호작용에 어떻게 반응하는가는 그 시점까지 객체에 어떤 일이 발생했느냐에 좌우된다.
상태를 이용하면 과거의 모든 행동ㅇ 이력을 설명하지 않고도 행동의 결과를 쉽게 예측하고 설명할 수 있다.
-> 상태를 이용하면 과거에 얽매이지 않고, 현재를 기반으로 객체의 행동 방식을 이해할 수 있다.

모든 객체의 상태는 **단순한 값과 객체의 조합**으로 표현할 수 있다. 이와 같이 객체의 상태를 구성하는 **모든 특징**을 통틀어 객체의 **프로퍼티(property)**라고 한다. 객체를 구성하는 모든 특징은 '정적'이지만 각 특징들의 값인 **프로퍼티 값(property value)**은 시간의 흐름에 따라 변경되므로 '동적'이다. 

객체와 객체 사이의 의미 있는 연결을 **링크(link)**라고 한다. 객체와 객체 사이에는 링크가 존재해야만 요청을 보내고 받을 수 있다. 즉, 객체의 링크를 통해서만 **메시지**를 주고받을 수 있다.

객체를 구성하는 단순한 값은 **속성(attribute)**이라고 한다.

> **상태**는 특정 시점에 객체가 가지고 있는 **정보의 집합**으로 객체의 구조적 특징을 표현한다. 객체의 상태는 객체에 존재하는 **정적인 프로퍼티와 동적인 프로퍼티 값으로 구성**된다. 객체의 프로퍼티는 단순한 값과 다른 객체를 참조하는 링크로 구분할 수 있다.

객체는 자율적인 존재라는 것을 명심해야 한다. 객체지향의 세계에서 객체는 다른 객체의 상태에 직접적으로 접근할 수도, 상태를 변경할 수 없다.
자율적인 객체는 스스로 자시느이 상태를 책임져야 한다. -> 간접적으로 객체의 상태를 변경하거나 조회할 수 있는 방법이 필요하다.

### **객체는 스스로의 행동에 의해서만 상태가 변경되는 것을 보장함으로써 객체의 자율성을 유지한다.**



### 행동

상태와 행동 사이의 관계

- 객체의 행동은 상태에 영향을 받는다. -> 객체의 상태가 행동의 영향을 받아야하지 않나? (고민)
- 객체의 행동은 상태를 변경시킨다.

상태라는 개념을 이용해 행동을 서술할 수 있는 두 가지 관점

1. 상호작용이 현재의 상태에 어떤 방식으로 **의존**하는가
2. 상호작용이 어떻게 현재의 상태를 **변경**시키는가

- 객체가 다른 객체와 협력하는 유일한 방법은 다른 객체에게 요청을 보내는 것이다.

객체의 행동은 아래 두 가지 관점의 부수효과를 명확하게 서술해야 한다.

1. 객체 자신의 상태 변경
2. 행동 내에서 협력하는 다른 객체에 대한 메시지 전송

> **행동**이란 **외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동**이다. **행동의 결과**로 **객체는 자신의 상태를 변경하거나 다른 객체에게 메시지를 전달**할 수 있다. 객체는 행동을 통해 다른 객체와의 협력에 참여하므로 **행동은 외부에 가시적**이어야 한다.
> 

### 상태 캡슐화

현실 세계에서는 앨리스가 마신 음료의 양은 앨리스가 줄인것이다. 하지만 객체 세계에서는 앨리스가 마신 음료의 양은 음료 스스로가 줄여야 한다.
-> 앨리스는 음료에 '음료를 마셨다'는 메시지만을 전달하고 이에 대한 결과로 음료 스스로가 음료의 양이라는 상태를 줄여야 한다.

엘리스든 다른 객체든 메시지 송신자는 메시지 수신자의 상태 변경에 대해서는 전혀 알지 못해야 한다.
객체가 외부에 노출하는 것은 행동 뿐이며, 외부에서 객체에 접근할 수 있는 유일한 방법 또한 행동뿐이다.

### **결론적으로 상태를 잘 정의된 행동 집합 뒤로 캡슐화 하는 것은 객체의 자율성을 높이고, 협력을 단순하고 유연하게 만든다.**



### 식별자
---
- 객체를 서로 구별할 수 있는 특정한 프로퍼티를 **식별자**라고 한다.
- 모든 객체는 식별자를 가지며 식별자를 이용해 객체를 구별할 수 있다.
- 객체가 아닌 단순한 값(value)은 식별자를 가지지 않는다.

**값(value)**은 숫자, 문자열, 날짜, 시간, 금액 등과 같이 변하지 않는 양을 모델링한다.

- 값의 상태는 변하지 않기 때문에 **불변 상태(immutable state)**를 가진다고 말한다.
- 값이 같은지 여부는 상태가 같은지를 이용해 판단한다.
    - 값의 상태가 같으면 두 인스턴스는 동일한 것으로 판단한다.
    - 상태를 이용해 두 값이 같은지 판단할 수 있는 성질을 **동등성(equality)**이라고 한다.
    - 값은 오직 상태만을 이용해 동등성을 판단하기 때문에 인스턴스를 구별하기 위한 별도의 식별자를 필요로 하지 않는다.

객체는 시간에 따라 변경되는 **상태(mutable state)**를 포함하며, 행동을 통해 상태를 변경한다.

- 식별자를 기반으로 객체가 같은지를 판단할 수 있는 성질을 **동일성(identical)**이라고 한다.

> 값은 상태를 이용한 동등성 검사를 통해 두 인스턴스를 비교한다. 객체는 상태가 변경될 수 있기 때문에 식벼자를 이용한 동일성 검사를 통해 두 인스턴스를 비교한다.


**참조 객체(reference object), 엔티티(entity)**

식별자를 지닌 전통적인 의미의 객체를 가리키는 용어

**값 객체(value object)**

식별자를 가지지 않는 값을 가리키는 용어

## 기계로서의 객체

- **쿼리(query)**: 객체의 상태를 **조회**하는 작업
- **명령(command)**: 객체의 상태를 **변경**하는 작업

버트란드 마이어의 객체 기계

- 공개적인 인터페이스를 통해서만 메시지를 받는다.
- 조회 버튼을 누르면 값을 조회할 수 있다.
- 명령 버튼을 누르면 프로퍼티의 값을 변경할 수 있다.

## 행동이 상태를 결정한다

협력에 참여하는 훌륭한 객체 시민을 양성하기 위한 가장 중요한 덕목은 상태가 아니라 행동에 초점을 맞추는 것이다. 객체는 다른 객체와 협력하기 위해 존재한다.

## 은유와 객체

현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다. 소프트웨어는 실제 세계의 모방이 아니라 새롭게 창조된 세계다.

### 의인화
현실 속의 객체와 소프트웨어 객체 사이의 가장 큰 차이점은 현실 속에서는 수동적인 존재가 소프트웨어 객체로 구현될 때는 능동적으로 변한다는 것이다. 
소프트웨어 객체를 창조할 때 우리는 결코 현실 세계의 객체를 모방하지 않는다. 
오히려 소프트웨어 안에 창조하는 객체에게 현실 세계의 객체와 전혀 다른 특징을 부여하는 것이 일반적이다.



---